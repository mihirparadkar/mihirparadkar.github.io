<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three things to never form</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="things-to-never-form-in-matrix-computations">Things to never form in matrix computations</h1>
<h2 id="the-matrix-inverse">1. The Matrix Inverse</h2>
<p>Commonly, the solution to systems of linear equations is expressed in the form
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><msup><mi>A</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mi>b</mi></mrow><annotation encoding="application/x-tex">
x = A^{-1}b
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.864108em;"></span><span class="strut bottom" style="height: 0.864108em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.864108em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span></span></span></span></span></span><span class="mord mathit">b</span></span></span></span></span></span>
where A is a square matrix and <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span></span> and <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">b</span></span></span></span></span> are vectors. In most numerical programming environments (e.g. numpy, Julia, MATLAB), this expression can be literally evaluated as something like this:</p>
<p><code>x = inv(A)*b</code>, or <code>x = numpy.linalg.inv(A)@(b)</code></p>
<p>One should resist the temptation to translate formulae literally. It is almost always superior to write</p>
<p><code>x = A \ b</code> or <code>x = numpy.linalg.solve(A, b)</code>
because it is both faster and usually more accurate on poorly-conditioned systems.</p>
<p>This <a href="https://www.mathworks.com/help/matlab/ref/inv.html">MATLAB documentation</a> explains further how these are different and why it is almost always better to use the <code>\</code> or <code>solve</code> operations. If solving multiple systems is required, then the matrix <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span></span> can be factorized via <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>L</mi><mi>U</mi></mrow><annotation encoding="application/x-tex">A = LU</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">A</span><span class="mrel">=</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.10903em;">U</span></span></span></span></span> (any non-singular matrix), <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>L</mi><msup><mi>L</mi><mi>H</mi></msup></mrow><annotation encoding="application/x-tex">A = LL^H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.841331em;"></span><span class="strut bottom" style="height: 0.841331em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">A</span><span class="mrel">=</span><span class="mord mathit">L</span><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span></span></span></span></span> (hermitian positive definite), or <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>L</mi><mi>D</mi><msup><mi>L</mi><mi>H</mi></msup></mrow><annotation encoding="application/x-tex">A = LDL^H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.841331em;"></span><span class="strut bottom" style="height: 0.841331em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">A</span><span class="mrel">=</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right: 0.02778em;">D</span><span class="mord"><span class="mord mathit">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span></span></span></span></span> decompositions (hermitian). Solving linear systems after such factorizations is a highly-optimized operation in the BLAS library underlying environments like Julia, numpy, and MATLAB. Inverting <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span></span> usually requires one of these factorizations internally, in addition to forming the inverse from said factorization. Factorizing first, then directly solving the system of equations doesn’t require the inverse, reducing computation time and numerical error.</p>
<h2 id="a-diagonal-matrix-from-a-vector">2. A diagonal matrix from a vector</h2>
<p>Some formulae require turning a vector into a diagonal matrix so as to do elementwise scaling on a vector, or row-wise/column-wise scaling on a matrix. Here are a couple examples:</p>
<ul>
<li>The singular value decomposition is commonly expressed as below, for example in the numpy documentation <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.linalg.svd.html">here</a>.
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi><mo>=</mo><mi>U</mi><mo>∗</mo><mi>d</mi><mi>i</mi><mi>a</mi><mi>g</mi><mo>(</mo><mi>S</mi><mo>)</mo><mo>∗</mo><mi>V</mi></mrow><annotation encoding="application/x-tex"> X = U * diag(S) * V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.07847em;">X</span><span class="mrel">=</span><span class="mord mathit" style="margin-right: 0.10903em;">U</span><span class="mbin">∗</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right: 0.22222em;">V</span></span></span></span></span></span></li>
<li>For linear machine learning models (logistic regression, least-squares, etc.), the Hessian matrix for Newton’s method is calculated as below
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>=</mo><msup><mi>X</mi><mi>T</mi></msup><mo>∗</mo><mi>d</mi><mi>i</mi><mi>a</mi><mi>g</mi><mo>(</mo><mfrac><mrow><msup><mi mathvariant="normal">∂</mi><mn>2</mn></msup><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mo>(</mo><mi>X</mi><mi>b</mi><msup><mo>)</mo><mn>2</mn></msup></mrow></mfrac><mo>)</mo><mo>∗</mo><mi>X</mi></mrow><annotation encoding="application/x-tex"> H = X^T * diag(\frac{\partial^2L}{\partial (Xb)^2}) * X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 1.49111em;"></span><span class="strut bottom" style="height: 2.42711em; vertical-align: -0.936em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.08125em;">H</span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right: 0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.891331em;"><span class="" style="top: -3.113em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.13889em;">T</span></span></span></span></span></span></span></span><span class="mbin">∗</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right: 0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.49111em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathrm" style="margin-right: 0.05556em;">∂</span><span class="mopen">(</span><span class="mord mathit" style="margin-right: 0.07847em;">X</span><span class="mord mathit">b</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.740108em;"><span class="" style="top: -2.989em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathrm" style="margin-right: 0.05556em;">∂</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span></span></span></span></span><span class="mord mathit">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.936em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right: 0.07847em;">X</span></span></span></span></span></span></li>
</ul>
<p>NumPy, Julia, and MATLAB provide a function <code>diag</code> that turns a vector <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">x</span></span></span></span></span> of length <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span> into a diagonal matrix <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.02778em;">D</span></span></span></span></span> of size <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.58333em;"></span><span class="strut bottom" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="base"><span class="mord mathit">n</span><span class="mbin">×</span><span class="mord mathit">n</span></span></span></span></span>, where <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>D</mi><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">x[i] = D[i,i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base"><span class="mord mathit">x</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathit" style="margin-right: 0.02778em;">D</span><span class="mopen">[</span><span class="mord mathit">i</span><span class="mpunct">,</span><span class="mord mathit">i</span><span class="mclose">]</span></span></span></span></span>. However, this function should almost never be necessary because all three of the above environments provide broadcasting functionality which has the same effect for much less computational cost and storage requirement.</p>
<p>For example, take the following expression:</p>
<p><code>A = U * diag(s) * Vt</code></p>
<p>For a matrix <code>A</code> with rank 10,000 , <code>diag(s)</code> requires storing 100,000,000 (<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 0.814108em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>) elements, of which 99,990,000 are zero. Furthermore, assuming <code>U</code> and <code>diag(s)</code> are <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>0</mn><mn>0</mn><mn>0</mn><mo>×</mo><mn>1</mn><mn>0</mn><mn>0</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">10000 \times 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="base"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mbin">×</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span></span> matrices, the first matrix multiplication requires on the order of <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>=</mo><mn>1</mn><msup><mn>0</mn><mrow><mn>1</mn><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^4 \times 10^4 \times 10^4 = 10^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 0.897438em; vertical-align: -0.08333em;"></span><span class="base"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">4</span></span></span></span></span></span></span></span><span class="mbin">×</span><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">4</span></span></span></span></span></span></span></span><span class="mbin">×</span><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">4</span></span></span></span></span></span></span></span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">1</span><span class="mord mathrm mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span> floating-point operations (more than a trillion multiplies + adds).</p>
<p>In Julia, the call to <code>diag(s)</code> can be replaced by <code>Diagonal(s)</code> with no changes to the rest of the code, as in</p>
<p><code>A = U * Diagonal(s) * Vt</code>.</p>
<p>This only requires storing 10,000 elements, and the first matrix multiplication only requires on the order of <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup></mrow><annotation encoding="application/x-tex">10^8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.814108em;"></span><span class="strut bottom" style="height: 0.814108em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">1</span><span class="mord"><span class="mord mathrm">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">8</span></span></span></span></span></span></span></span></span></span></span></span> floating-point operations. This works because multiplication by a diagonal matrix (<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>∗</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">A * D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">A</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right: 0.02778em;">D</span></span></span></span></span>) is equivalent to scaling the columns of <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span></span> by the elements of <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">D</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.02778em;">D</span></span></span></span></span>, and <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>∗</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">D*A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.02778em;">D</span><span class="mbin">∗</span><span class="mord mathit">A</span></span></span></span></span> works the same except it scales the rows of <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span></span>.</p>
<p>In numpy , the more efficient solution uses broadcasting, which works the same way as in Julia, but isn’t a simple drop-in replacement.</p>
<p>In numpy, multiplying a matrix by a diagonal matrix (represented as a vector) can be done as follows:</p>
<p><code>A = (U * s)@(Vt)</code>, or <code>A = (U * s[None,:])@(Vt)</code> if you want to be more specific.</p>
<p>Left-multiplying by a diagonal can be done like so: <code>A = U@( s[:, None] * Vt )</code></p>
<h2 id="the-covariancegram-matrix">3. The Covariance/Gram Matrix</h2>
<p>The gram matrix is given by <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>A</mi><mi>H</mi></msup><mi>A</mi></mrow><annotation encoding="application/x-tex">A^HA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.841331em;"></span><span class="strut bottom" style="height: 0.841331em; vertical-align: 0em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span><span class="mord mathit">A</span></span></span></span></span> for a matrix <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">A</span></span></span></span></span>. The gram matrix or its scaled variants (such as the covariance matrix) represent a third type of matrix that should (almost) never be formed. The reason for this is that there are two main applications for the gram matrix: Using it in a system of equations, or finding its eigen-system.</p>
<p>The gram matrix is usually involved in a system of equations when the objective is to find a least-squares approximation. This system usually looks like</p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msup><mi>A</mi><mi>H</mi></msup><mi>A</mi><mo>)</mo><mi>b</mi><mo>=</mo><msup><mi>A</mi><mi>H</mi></msup><mi>y</mi></mrow><annotation encoding="application/x-tex">(A^HA)b = A^Hy</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.841331em;"></span><span class="strut bottom" style="height: 1.09133em; vertical-align: -0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span><span class="mord mathit">A</span><span class="mclose">)</span><span class="mord mathit">b</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span><span class="mord mathit" style="margin-right: 0.03588em;">y</span></span></span></span></span>.</p>
<p>While the system can be solved by explicitly computing
<code>cholfact(A'A) \ (A'y)</code> (Julia syntax), this only works when the Gram matrix is full rank (i.e. A has full column rank). In this case, the QR decomposition method is more numerically stable in the case of a poorly-conditioned system. The QR factorization approach is also the default one implemented for the proper solution in this case, which is simply <code>A \ y</code>.</p>
<p>Additionally, when the Gram matrix is not full-rank, the factorization is impossible. In this case, the backslash operator or <code>solve</code> function in NumPy automatically switch to the SVD-based solution, while the explicit Gram matrix solution will just throw an error.</p>
<p>The other main reason the Gram matrix is commonly formed is to find its eigen-system for procedures like Principal Components Analysis (PCA) or data whitening. However, these can be more easily and stably computed via the Singular Value Decomposition. Here’s how:</p>
<p>Let <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>A</mi><mi>H</mi></msup><mi>A</mi><mo>=</mo><mi>V</mi><mi mathvariant="normal">Σ</mi><msup><mi>V</mi><mi>H</mi></msup></mrow><annotation encoding="application/x-tex">A^HA = V\Sigma V^H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.841331em;"></span><span class="strut bottom" style="height: 0.841331em; vertical-align: 0em;"></span><span class="base"><span class="mord"><span class="mord mathit">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span><span class="mord mathit">A</span><span class="mrel">=</span><span class="mord mathit" style="margin-right: 0.22222em;">V</span><span class="mord mathrm">Σ</span><span class="mord"><span class="mord mathit" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>However, <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.22222em;">V</span></span></span></span></span> and <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">Σ</span></span></span></span></span> can also be obtained through the singular value decomposition of A</p>
<p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>U</mi><mi>S</mi><msup><mi>V</mi><mi>H</mi></msup></mrow><annotation encoding="application/x-tex">A = USV^H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.841331em;"></span><span class="strut bottom" style="height: 0.841331em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">A</span><span class="mrel">=</span><span class="mord mathit" style="margin-right: 0.10903em;">U</span><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="mord"><span class="mord mathit" style="margin-right: 0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.841331em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.08125em;">H</span></span></span></span></span></span></span></span></span></span></span></span>, and <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><msqrt><mrow><mi mathvariant="normal">Σ</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">S = \sqrt{\Sigma}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.926665em;"></span><span class="strut bottom" style="height: 1.04em; vertical-align: -0.113335em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.05764em;">S</span><span class="mrel">=</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist svg-align" style="height: 0.926665em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord" style="padding-left: 0.833em;"><span class="mord mathrm">Σ</span></span></span><span class="" style="top: -2.88666em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail" style="min-width: 0.853em; height: 1em;"><svg width="400em" height="1em" viewBox="0 0 400000 1000" preserveAspectRatio="xMinYMin slice"><path d="M95 622c-2.667 0-7.167-2.667-13.5
-8S72 604 72 600c0-2 .333-3.333 1-4 1.333-2.667 23.833-20.667 67.5-54s
65.833-50.333 66.5-51c1.333-1.333 3-2 5-2 4.667 0 8.667 3.333 12 10l173
378c.667 0 35.333-71 104-213s137.5-285 206.5-429S812 17.333 812 14c5.333
-9.333 12-14 20-14h399166v40H845.272L620 507 385 993c-2.667 4.667-9 7-19
7-6 0-10-1-12-3L160 575l-65 47zM834 0h399166v40H845z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.113335em;"></span></span></span></span></span></span></span></span></p>
<p>The SVD method not only avoids computing the Gram matrix, but doesn’t waste time computing singular values with value 0, something that the eigenvalue solver cannot figure out as easily.</p>
<h2 id="conclusions">Conclusions</h2>
<p>Three common matrices in linear algebra computing never need to be formed: the inverse, full diagonal, and Gram matrix. While it can be tempting to literally translate from formulae to code, there are usually highly optimized methods for solving these common problems. Furthermore, even though it is true that one should avoid premature optimization, these optimizations come for free, both in terms of compute cost and often in readability.</p>
</div>
</body>

</html>
